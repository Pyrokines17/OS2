```c
int sigemptyset(sigset_t *set);

int sigfillset(sigset_t *set);

int sigaddset(sigset_t *set, int signum);
```

Эти функции позволяют манипулировать наборами сигналов POSIX.

- `sigemptyset()` 
	инициализирует набор сигналов, заданный set, пустым, со всеми сигналами,исключенными из набора.
- `sigfillset()` 
	инициализирует set полным, включая все сигналы.
- `sigaddset()` и `sigdelset()` 
	добавляют и удаляют соответственно сигнал `signum` из набора.
- `sigismember()` 
	проверяет, является ли `signum` членом набора.

---

Объекты типа `sigset_t` должны быть инициализированы вызовом `sigemptyset()` или `sigfillset()` перед передачей в функции `sigaddset()`, `sigdelset()` и `sigismember()` или дополнительные функции `glibc`, описанные ниже (`sigisemptyset()`, `sigandset()` и `sigorset()`). Результаты не определены, если это не сделано.

При создании заполненного набора сигналов функция `glibc` `sigfillset()` не включает два сигнала реального времени, используемых внутренне реализацией потоков `NPTL`. Подробнее см. `nptl(7)`.

---

`int sigwait(const sigset_t *set, int *sig);`

Функция `sigwait()` приостанавливает выполнение вызывающего потока до тех пор, пока один из сигналов, указанных в наборе сигналов, не станет ожидающим. Функция принимает сигнал (удаляет его из списка ожидающих сигналов) и возвращает номер сигнала в `sig`. Реализация `sigwait()` в `glibc` молча игнорирует попытки ожидания двух сигналов реального времени, которые используются внутри реализации потоков `NPTL`.

---

`int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);`
https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=sigaction&category=2

`sigaction()` можно вызвать со вторым аргументом NULL, чтобы запросить текущий обработчик сигналов. Его также можно использовать для проверки, является ли данный сигнал допустимым для текущей машины, вызвав его со вторым и третьим аргументами NULL.

---

`int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`

`sigprocmask()` используется для извлечения и/или изменения маски сигнала вызывающего потока. Маска сигнала — это набор сигналов, доставка которых в данный момент заблокирована для вызывающего (см. также `signal(7)` для получения более подробной информации).

Поведение вызова зависит от значения `how`, как следует.

`SIG_BLOCK`
	Набор заблокированных сигналов — это объединение текущего набора и аргумента set.
`SIG_UNBLOCK`
	Сигналы в set удаляются из текущего набора заблокированных сигналов. Допустимо попытаться разблокировать сигнал, который не заблокирован.
`SIG_SETMASK`
	Набор заблокированных сигналов устанавливается в аргумент set.

Если `oldset` не равен NULL, предыдущее значение маски сигнала сохраняется в `oldset`.

Если set равен NULL, то маска сигнала не изменяется (`how` игнорируется), но текущее значение маски сигнала тем не менее возвращается в `oldset` (если оно не равно NULL).

Невозможно заблокировать `SIGKILL` или `SIGSTOP`, попытки игнорируются

---

`int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);`

Потоки наследуют копию маски сигналов создающего потока

---

`SIGQUIT` — сигнал, используемый в POSIX-системах, посылаемый процессу для остановки и указывающий, что система должна выполнить дамп памяти для процесса. Определён как целочисленная константа в заголовочном файле signal.h. 
`SIGINT` — сигнал, применяемый в POSIX-системах для остановки процесса пользователем с терминала.

Сигналы `SIGKILL` и `SIGSTOP` не могут быть заблокированы или проигнорированы и на них нельзя установить свой обработчик.

---

Command:
`kill -QUIT %1`

