На хорошо:

- Создание lib:
  
  1) `gcc -c <file>.c`
  
  2) `ar r lib<name>.a <files>.o`
  
  3) `gcc -c <main>.c`
  
  4) `gcc -o <name> <main>.o -L<PathToLib> -l<libName>`

- __sync_lock_release: Эта функция освобождает блокировку, полученную функцией __sync_lock_test_and_set, и присваивает переменной, на которую указывает __p, значение ноль. При вызове этой функции создается барьер освобождения памяти.

- __sync_lock_test_and_set: Эта функция атомарно присваивает значение __v переменной, на которую указывает __p. При вызове этой функции создается барьер приобретаемой памяти.

- Flags: (SIGCHLD | CLONE_VM | CLONE_SIGHAND | CLONE_FS | CLONE_FILES)
  
  1. SIGCHLD: Когда дочерний процесс завершается, родительскому может быть послан сигнал. Сигнал завершения указывается в младшем байте flags (clone()) или в cl_args.exit_signal (clone3()). Если этот сигнал указан не как SIGCHLD, то родительский процесс должен указать опции __WALL или __WCLONE при ожидании дочернего процесса с помощью wait(2). Если сигнал не указан, то родительский процесс не получает сигнала о завершении работы дочернего процесса.
  
  2. CLONE_VM: Если CLONE_VM установлен, вызывающий и дочерний процессы работают в одном и том же пространстве памяти. В частности, записи в память, выполняемые вызывающим или дочерним процессом, видны и другому процессу. Более того, любое отображение или разгруппирование памяти, выполняемое с помощью mmap(2) или munmap(2) дочерним или вызывающим процессом, также влияет на другой процесс. Если значение CLONE_VM не установлено, дочерний процесс работает в отдельной копии пространства памяти вызывающего процесса во время вызова клона. Запись в память или отображение/развертывание файлов, выполняемые одним из процессов, не влияют на другой, как в случае с fork(2).
  
  3. CLONE_SIGHAND: Если установлено значение CLONE_SIGHAND, вызывающий и дочерний процессы используют одну и ту же таблицу обработчиков сигналов. Если вызывающий или дочерний процесс вызывает sigaction(2) для изменения поведения, связанного с сигналом, это поведение изменяется и в другом процессе. Однако вызывающий и дочерний процессы по-прежнему имеют разные маски сигналов и наборы ожидающих сигналов. Таким образом, один из них может блокировать или разблокировать сигналы с помощью sigprocmask(2), не влияя на другой процесс. Если значение CLONE_SIGHAND не установлено, дочерний процесс наследует копию обработчиков сигналов вызывающего процесса на момент вызова клона. Вызовы sigaction(2), выполненные позже одним из процессов, не влияют на другой процесс. Начиная с Linux 2.6.0, маска флагов должна также включать CLONE_VM, если указано CLONE_SIGHAND.
  
  4. CLONE_FS: Если установлено значение CLONE_FS, вызывающий и дочерний процессы используют одну и ту же информацию о файловой системе. Это включает корень файловой системы, текущий рабочий каталог и umask. Любой вызов chroot(2), chdir(2) или umask(2), выполненный вызывающим или дочерним процессом, также влияет на другой процесс. Если значение CLONE_FS не установлено, дочерний процесс работает с копией информации о файловой системе вызывающего процесса на момент вызова клонирования. Вызовы chroot(2), chdir(2) или umask(2), выполненные позже одним из процессов, не влияют на другой процесс.
  
  5. CLONE_FILES: Если установлено значение CLONE_FILES, вызывающий процесс и дочерний процесс совместно используют одну и ту же таблицу дескрипторов файлов. Любой файловый дескриптор, созданный вызывающим или дочерним процессом, будет действителен и в другом процессе. Аналогично, если один из процессов закрывает файловый дескриптор или изменяет связанные с ним флаги (с помощью операции fcntl(2) F_SETFD), это затрагивает и другой процесс. Если процесс, разделяющий таблицу файловых дескрипторов, вызывает execve(2), его таблица файловых дескрипторов дублируется (не разделяется). Если значение CLONE_FILES не установлено, дочерний процесс наследует копию всех файловых дескрипторов, открытых в вызывающем процессе на момент вызова клонирования. Последующие операции по открытию или закрытию дескрипторов файлов или изменению флагов дескрипторов файлов, выполняемые как вызывающим, так и дочерним процессом, не влияют на другой процесс. Обратите внимание, однако, что дублированные дескрипторы файлов в дочернем процессе ссылаются на те же описания открытых файлов, что и соответствующие дескрипторы файлов в вызывающем процессе, и, следовательно, имеют общие смещения файлов и флаги состояния файлов (см. open(2)).
